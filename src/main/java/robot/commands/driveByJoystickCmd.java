// RobotBuilder Version: 4.0
//
// This file was generated by RobotBuilder. It contains sections of
// code that are automatically generated and assigned by robotbuilder.
// These sections will be updated in the future when you export to
// Java from RobotBuilder. Do not put any code or make any change in
// the blocks indicating autogenerated code or it will be lost on an
// update. Deleting the comments indicating the section will prevent
// it from being updated in the future.

// ROBOTBUILDER TYPE: Command.

package robot.commands;
import robot.RobotContainer;
import edu.wpi.first.math.filter.SlewRateLimiter;
import edu.wpi.first.math.kinematics.ChassisSpeeds;
import edu.wpi.first.math.kinematics.SwerveModuleState;
import edu.wpi.first.wpilibj.Joystick;
import edu.wpi.first.wpilibj2.command.CommandBase;
import robot.Constants.DriveTrainConstants;
import robot.Constants.OIConstants;

import robot.subsystems.drivetrainSubSys;


public class driveByJoystickCmd extends CommandBase {

    private final drivetrainSubSys m_drivetrainSubSys;
    private Joystick m_joystick;

    private SlewRateLimiter xLimiter;
    private SlewRateLimiter yLimiter;
    private SlewRateLimiter turningLimiter;


    public driveByJoystickCmd(drivetrainSubSys subsystem ) {
        m_drivetrainSubSys = subsystem;
        addRequirements(m_drivetrainSubSys);
        this.xLimiter = new SlewRateLimiter(DriveTrainConstants.kTeleDriveMaxAccelerationUnitsPerSecond);
        this.yLimiter = new SlewRateLimiter(DriveTrainConstants.kTeleDriveMaxAccelerationUnitsPerSecond);
        this.turningLimiter = new SlewRateLimiter(DriveTrainConstants.kTeleDriveMaxAngularAccelerationUnitsPerSecond);
    }

    // Called when the command is initially scheduled.
    @Override
    public void initialize() {
        m_joystick = RobotContainer.getInstance().getdriverJoy();
    }

    // Called every time the scheduler runs while the command is scheduled.
    @Override
    public void execute() {

        // Step 1 - Get joystick Inputs
        // Step 1a) Get joystick inputs from individual axis
            double xSpeed = m_joystick.getY();      // NOTE: "Y" axis to get "X" (Fwd/Back) Speed
            double ySpeed = m_joystick.getX();      // NOTE: "X" axis to get "Y" (Left/RT)  Speed
            double turningSpeed = m_joystick.getTwist();
            double throttle = (-m_joystick.getThrottle()/2) + 0.5; // convert from ( -1:1 ) to ( 0:1 ) 

        // Step 1b) Apply deadband (in case joystick doesn't return fully to Zero position)
            xSpeed = deadBand(xSpeed);
            ySpeed = deadBand(ySpeed);
            turningSpeed = deadBand(turningSpeed);

        // Step 1c) Limit Speeds based on throttle setting
            xSpeed *= throttle;
            ySpeed *= throttle;
            turningSpeed *= throttle;
            // If Using Xbox Controller with no throttle use limiting constants from Constants
            //xSpeed = xSpeed * DriveTrainConstants.kTeleDriveThrottle;
            //ySpeed = ySpeed * DriveTrainConstants.kTeleDriveThrottle;
            //turningSpeed = turningSpeed * DriveTrainConstants.kTeleDriveThrottle;

        // Step 2a) - Convert Joystick values to Field Velocity (Meters/Sec)
            xSpeed *= DriveTrainConstants.kTeleDriveMaxSpeedMetersPerSecond;
            ySpeed *= DriveTrainConstants.kTeleDriveMaxSpeedMetersPerSecond;
            turningSpeed *= DriveTrainConstants.kTeleDriveMaxAngularSpeedRadiansPerSecond;

        // Step 2b) - Limit Field Velocities based upon MAX acceleration constants
            xSpeed = xLimiter.calculate(xSpeed);
            ySpeed = xLimiter.calculate(ySpeed);
            turningSpeed = xLimiter.calculate(turningSpeed);

        // Step 3 - Create a "Chassis Speeds" Object from field velocity targets and current Gyro Angle
        ChassisSpeeds chassisSpeeds;
        if(  m_joystick.getRawButton(OIConstants.kDriverChassisOrientedButtonIdx)){
            // Chassis Relative
            chassisSpeeds = new ChassisSpeeds(xSpeed, ySpeed, turningSpeed);
        } else {
            // Field Relative
            chassisSpeeds = ChassisSpeeds.fromFieldRelativeSpeeds(
                    xSpeed, ySpeed, turningSpeed, m_drivetrainSubSys.getGyroHeadingRotation2d());
        }

        // Step 4 - Create a "Swerve Module States" object from the "chassis Speeds" object
        // This creates a SwerveModuleState Array of Swerve Drive States.
        // Each array element contains "Drive-Velocity" and "Turn-Angle" values. 
        SwerveModuleState[] moduleStates = DriveTrainConstants.kDriveKinematics.toSwerveModuleStates(chassisSpeeds);

        // Step 5 - Send "Swerve Module States" to Drivetrain Motors
        m_drivetrainSubSys.setModuleStates(moduleStates);
    }

    // Called once the command ends or is interrupted.
    @Override
    public void end(boolean interrupted) {
        m_drivetrainSubSys.stopModules();
    }

    // Returns true when the command should end.
    @Override
    public boolean isFinished() {
        return false;
    }

    public double deadBand(double value){
        // Deadband Calculation
        if((value <=  OIConstants.kDeadband) && (value >= - OIConstants.kDeadband)){
            return 0;
        }
        if (value > 0) {
            value=(value - OIConstants.kDeadband) * (1 + OIConstants.kDeadband);		// Scale Yvalue smoothly to + 1
        } else {
            value = - (-value - OIConstants.kDeadband) * (1 + OIConstants.kDeadband);	// Scale Yvalue smoothly to -1
        }
        return value;
    }

    @Override
    public boolean runsWhenDisabled() {
        // BEGIN AUTOGENERATED CODE, SOURCE=ROBOTBUILDER ID=DISABLED
        return false;

    // END AUTOGENERATED CODE, SOURCE=ROBOTBUILDER ID=DISABLED
    }
}
